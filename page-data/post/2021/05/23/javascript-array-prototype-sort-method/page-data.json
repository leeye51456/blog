{"componentChunkName":"component---src-templates-post-js","path":"/post/2021/05/23/javascript-array-prototype-sort-method","result":{"data":{"markdownRemark":{"html":"<h2>정리하게 된 동기</h2>\n<p>요즘에는 가능하면 코딩 테스트 문제를 JavaScript로만 풀려고 한다. 언젠가는 정렬이 필요한 문제를 JavaScript로 풀었다. 한 부분만 빼고는 제대로 풀었는데, 그 한 부분을 잘못 작성해서 한 문제를 버리게 될 뻔했다. 다행히 다른 코너 케이스를 찾다가 얻어 걸려서, 배열의 <code>sort()</code> 메서드를 잘못 사용했다는 것을 발견했다.</p>\n<p>사실은 이전에도, <code>Array.prototype.sort()</code> 메서드가 기본적으로는 배열의 내용을 문자열로 바꾼 것을 기준으로 정렬한다는 것을 본 적이 있었다. 그런데도 잊어버리고 같은 내용을 또 틀렸다. 그래서 한번 제대로 정리해서 기록해 둘 필요를 느꼈다.</p>\n<hr>\n<h2><code>Array.prototype.sort()</code>의 사용법</h2>\n<p>메서드에 아무 인수도 주지 않으면 배열의 각 원소를 문자열로 취급하여 UTF-16 인코딩 기준 오름차순으로 제자리에서(in-place) 정렬한다. 그리고 정렬한 배열을 리턴한다. 정렬은 stable하지 않을 수 있다.</p>\n<pre><code class=\"language-javascript\">const a = ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'];\nconst b = a.sort();\nconsole.log(b); // ['Lorem', 'amet', 'dolor', 'ipsum', 'sit']\nconsole.log(a); // ['Lorem', 'amet', 'dolor', 'ipsum', 'sit']\nconsole.log(a === b); // true\n</code></pre>\n<p>예제에서 이상해 보이는 부분이 몇 가지 보이는데, 이 부분은 조금 뒤에 다룰 것이다.</p>\n<h3>비교 함수 사용하기</h3>\n<p>메서드에 <code>(a: any, b: any) => number</code> 형태의 비교 함수를 인수로 주면, 규칙에 따라 정렬한다.</p>\n<ul>\n<li>(리턴 값) &#x3C; 0: <code>a</code>가 <code>b</code>보다 앞에 온다.</li>\n<li>\n<p>(리턴 값) = 0</p>\n<ul>\n<li>(ES2019 스펙부터) <code>a</code>와 <code>b</code>의 순서를 유지한다.</li>\n<li>(ES2019보다 과거 스펙에서) <code>a</code>와 <code>b</code>의 순서를 보장하지 않는다.</li>\n</ul>\n</li>\n<li>(리턴 값) > 0: <code>a</code>가 <code>b</code>보다 뒤에 온다.</li>\n<li>비교 함수의 리턴 값에 모순이 있으면 정렬 순서는 알 수 없다.</li>\n</ul>\n<p>비교 함수를 정의하지 않으면 배열의 각 원소를 문자열로 취급하여 비교하므로, <code>number[]</code> 배열은 정렬이 제대로 되지 않는다. MDN의 JavaScript 레퍼런스에 그 예제가 잘 나와 있다.</p>\n<pre><code class=\"language-javascript\">// Any copyright is dedicated to the Public Domain.\n// http://creativecommons.org/publicdomain/zero/1.0/\n// Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n\nconst array1 = [1, 30, 4, 21, 100000];\narray1.sort();\nconsole.log(array1);\n// expected output: Array [1, 100000, 21, 30, 4]\n</code></pre>\n<p>따라서 <code>number[]</code> 배열을 오름차순으로 올바르게 정렬하기 위해서는 다음과 같이 비교 함수를 전달해야 한다. (단, <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>는 고려하지 않는다고 가정한다.)</p>\n<pre><code class=\"language-javascript\">const c = [1, 30, 4, 21, 100000];\nc.sort((a, b) => a - b);\nconsole.log(c); // [ 1, 4, 21, 30, 100000 ]\n</code></pre>\n<hr>\n<h2>짚고 넘어가야 하는 주의사항</h2>\n<p>예제도, 설명도 별로 어렵지 않아 보이지만, 다음 내용을 주의깊게 생각하지 않으면 잘못 사용하기 좋다.</p>\n<h3>1. 기본 정렬 방식: <mark>UTF-16</mark> <mark>문자열로 취급</mark>하여 오름차순 정렬</h3>\n<p>맨 처음 예제의 정렬 결과에서 <code>'Lorem'</code>이 <code>'amet'</code>보다 먼저 나왔다. 두 문자열의 첫 글자인 ‘L’(U+004C)과 ‘a’(U+0061) 중 ‘L’이 UTF-16 으로 인코딩된 내용상 먼저이기 때문이다. UTF-16으로 인코딩된 데이터 순서가 아니라 정말 사전순으로 정렬하려는 상황에는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\"><code>String.prototype.localeCompare()</code></a> 메서드를 활용하라고 MDN 문서에 나와 있다.</p>\n<p>그렇다면 UTF-16에서 두 글자로 나누어 표현되는 문자(U+10000부터)는 어떻게 될까? 결론부터 얘기하자면, 코드포인트를 비교하지 않고 나누어진 글자 단위로 비교하기 때문에 꼭 코드포인트 순서대로 정렬되지는 않는다. 코드포인트상으로는 ‘🥳’(U+1F973, Partying Face) 이모지가 ‘Ａ’(U+FF21, Fullwidth Latin Capital Letter A)보다 나중에 나온다. 하지만 JavaScript에서는 UTF-16 인코딩에 따라 ‘🥳’ 이모지를 <code>'\\uD83E\\uDD73'</code>으로 취급한다.(<code>'🥳'.length</code>를 테스트하면 <code>2</code>이다.) 따라서 두 문자를 정렬할 때 <code>'\\uD83E'</code>와 <code>'\\uFF21'</code>을 비교하게 되고, ‘🥳’ 이모지가 ‘Ａ’보다 먼저 오도록 정렬한다.</p>\n<pre><code class=\"language-javascript\">const d = ['Ａ', '🥳']; // 또는, const d = ['\\uFF21', '\\u{1F973}'];\nconsole.log(d.sort()); // [ '🥳', 'Ａ' ]\n</code></pre>\n<p>한편, 문자열이 아닌 것을 정렬하려면 앞에서 설명한 것처럼 비교 함수를 사용해야 한다. 이때 비교 함수의 리턴 값에 주의할 필요가 있다. 비교 함수는 결과가 0이거나, 0보다 작거나, 큰 값이 되도록 작성해야 한다. 비교 함수가 <code>NaN</code> 같은 값을 리턴하면(예: <code>Infinity - Infinity</code>) 올바른 정렬 순서가 보장되지 않는다.</p>\n<h3>2. Stable Sort가 아닐 수도 있음</h3>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\">MDN 영문 레퍼런스</a>에 따르면, ES2019 스펙부터 <code>Array.prototype.sort()</code>가 stable sort라고 한다. 레퍼런스를 읽어 보면, 이는 비교 함수의 리턴 값을 0과 비교하는지에 따라 결정된다는 것을 알 수 있다.</p>\n<p>웹 브라우저별 stable sort 지원 여부는 MDN 레퍼런스 페이지와 <a href=\"https://caniuse.com/mdn-javascript_builtins_array_sort_stable\">caniuse.com</a> 등에서 확인할 수 있다. IE와 레거시 Edge를 제외한 웬만한 브라우저에서 stable sort를 지원한다. <a href=\"https://node.green/\">node.green</a>에 따르면 Node.js에서는 12.0.0 버전부터 ES2019 스펙을 지원한다. 이 버전부터는 stable sort 지원이 보장된다.(표에 stable sort가 직접적으로 언급되지는 않음)</p>\n<h3>3. In-Place Sort: 원본 배열을 변경함</h3>\n<p><code>Array.prototype.sort()</code>는 원본 배열을 변경한다. 첫 번째 예제를 다시 보자.</p>\n<pre><code class=\"language-javascript\">const a = ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'];\nconst b = a.sort();\nconsole.log(b); // [ 'Lorem', 'amet', 'dolor', 'ipsum', 'sit' ]\nconsole.log(a); // [ 'Lorem', 'amet', 'dolor', 'ipsum', 'sit' ]\nconsole.log(a === b); // true\n</code></pre>\n<p><code>a.sort()</code>는 배열 <code>a</code> 자체를 변경한 뒤에 자기 자신을 리턴한다. 따라서 <code>b</code>는 <code>a</code>와 (레퍼런스가) 동일한 배열이고, <code>a === b</code>를 테스트해 보면 <code>true</code>가 나온다. 원본 배열을 변경하지 않으려면, 간단하게는 다음과 같이 원본 배열을 복제해서 정렬하는 방법을 쓸 수 있다.</p>\n<pre><code class=\"language-javascript\">const e = ['Lorem', 'ipsum', 'dolor', 'sit', 'amet'];\nconst f = [...e].sort();\nconsole.log(e); // [ 'Lorem', 'ipsum', 'dolor', 'sit', 'amet' ]\nconsole.log(f); // [ 'Lorem', 'amet', 'dolor', 'ipsum', 'sit' ]\nconsole.log(e === f); // false\n\ne.sort();\nconsole.log(e); // [ 'Lorem', 'amet', 'dolor', 'ipsum', 'sit' ]\nconsole.log(e === f); // false\n</code></pre>\n<h3>4. 비교 함수의 일관성</h3>\n<p>당연한 얘기지만, 비교 함수는 모순되지 않는 결과를 리턴해야 한다. 그렇지 않으면 정렬 순서가 보장되지 않는다. 예를 들어서, — 대소관계로 표현하긴 부적절해 보이지만 — 가위바위보에는 다음과 같은 상성이 있다.(큰 쪽이 작은 쪽을 이김)</p>\n<ul>\n<li>가위 &#x3C; 바위 — (1)</li>\n<li>바위 &#x3C; 보자기 — (2)</li>\n<li>보자기 &#x3C; 가위 — (3)</li>\n</ul>\n<p>여기서 (1), (2)에 따르면 <mark>가위 &#x3C; 보자기</mark>이지만, 이는 (3)에 모순이다. 이렇게 비교 함수의 리턴 값에 모순이 있으면 정렬 순서가 보장되지 않는다.</p>\n<h3>5. <code>undefined</code>인 원소 처리</h3>\n<p>JavaScript 배열의 <code>sort()</code> 메서드에서는 <code>undefined</code>를 다음과 같이 다룬다.</p>\n<p>첫째, 비교 함수 전달의 유무와 관계없이 <code>undefined</code>를 배열의 맨 뒤로 옮긴다.</p>\n<pre><code class=\"language-javascript\">const g = [\n  ...new Array(3).fill(undefined),\n  ...new Array(3).fill('undefined'),\n  ...new Array(3).fill('undefinedd'),\n  ...new Array(3).fill('undefine'),\n];\n\n// shuffle(array: any[]) => any[] - `array`의 원소의 순서를 무작위로 변경하는 함수라고 가정\nconst h = shuffle([...g]);\n// [ 'undefined', 'undefined', 'undefine',\n//   undefined, 'undefinedd', 'undefined',\n//   'undefine', 'undefinedd', 'undefine',\n//   'undefinedd', undefined, undefined ]\n\nconst i = [...h].sort();\n// [ 'undefine', 'undefine', 'undefine',\n//   'undefined', 'undefined', 'undefined',\n//   'undefinedd', 'undefinedd', 'undefinedd',\n//   undefined, undefined, undefined ]\n</code></pre>\n<p>둘째, <code>undefined</code>는 비교 함수에서 취급되지 않는다. 아래 예제에서는 비교 함수의 매개변수 중 하나가 <code>undefined</code>이면 두 매개변수를 출력하게 되어 있지만, 해당 내용은 출력되지 않는다.</p>\n<pre><code class=\"language-javascript\">const j = [undefined, 'undefined', 'undefinedd', 'undefine'];\nj.sort((a, b) => {\n  if (a === undefined || b === undefined) {\n    console.log('a:', a, '   b:', b);\n  }\n  if (a == b) {\n    return 0;\n  }\n  return String(a) &#x3C; String(b) ? -1 : 1;\n});\n// [ 'undefine', 'undefined', 'undefinedd', undefined ] (정렬 도중 출력은 없음)\n</code></pre>\n<p>이 예제에서 <code>undefined</code>를, <code>null</code>로 바꾸면, <code>null</code>과 비교가 이루어지고 <code>null</code>이 정렬 결과의 중간 부분에 끼는 것을 볼 수 있다.</p>\n<hr>\n<h2>요약</h2>\n<p><code>Array.prototype.sort()</code>는...</p>\n<ol>\n<li>비교 함수를 전달하지 않으면 UTF-16 문자열로 취급하여 오름차순으로 정렬한다.</li>\n<li>Stable Sort가 아닐 수도 있다.</li>\n<li>원본 배열을 변경한다.</li>\n<li>비교 함수를 전달할 때, 비교 함수의 리턴 값에 모순이 없어야 한다.</li>\n<li><code>undefined</code>를 맨 뒤로 보낸다.</li>\n</ol>\n<hr>\n<h2>참고 자료</h2>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\">Array.prototype.sort()</a> — MDN Web Docs (English)</li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\">Array.prototype.sort()</a> — MDN Web Docs (한국어)</li>\n<li><a href=\"https://v8.dev/blog/array-sort\">Getting things sorted in V8</a> — V8 Blog</li>\n</ul>","frontmatter":{"slug":"/post/2021/05/23/javascript-array-prototype-sort-method","date":"2021-05-23","revisions":[],"title":"JavaScript 배열의 sort() 메서드","description":"코딩 테스트에서 한 문제를 날려 먹을 뻔해서 정리한, JavaScript 배열 정렬 메서드\n","license":{"post":"CC BY-NC 4.0","code":"The Unlicense"},"keywords":["JavaScript","ECMAScript"]}}},"pageContext":{"slug":"/post/2021/05/23/javascript-array-prototype-sort-method"}},"staticQueryHashes":["3649515864","63159454"]}